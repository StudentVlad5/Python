# Іменований кортеж створюється за допомогою функції namedtuple з модуля collections.
from collections import namedtuple

# Створення іменованого кортежу
Point = namedtuple('Point', ['x', 'y'])
print(Point)
# Створення екземпляра Point
p = Point(11, y=22)

# Доступ до елементів
print(p.x)  # 11
print(p.y)  # 22

# Створення іменованого кортежу Person
Person = namedtuple('Person', ['first_name', 'last_name', 'age', 'birth_place', 'post_index'])

# Створення екземпляра Person
person = Person('Mick', 'Nitch', 35, 'Boston', '01146')

# Виведення різних атрибутів іменованого кортежу
print(person.first_name)       
print(person.post_index) 
print(person.age)        
print(person[3])   

import collections

Cat = collections.namedtuple('Cat', ['nickname', 'age', 'owner'])
cat = Cat('Simon', 4, 'Krabat')
print(f'This is a cat {cat.nickname}, {cat.age} age, his owner {cat.owner}')
print(f'This is a cat {cat[0]}, {cat[1]} age, his owner {cat[2]}')

# Counter
student_marks = [4, 2, 4, 6, 7, 4, 2, 3, 4, 5, 6, 6, 7, 1, 1, 1, 3, 5]
mark_counts = {}
for mark in student_marks:
    if mark in mark_counts:
        mark_counts[mark] += 1
    else:
        mark_counts[mark] = 1

print(mark_counts)

import collections

student_marks = [4, 2, 4, 6, 7, 4, 2, 3, 4, 5, 6, 6, 7 , 1, 1, 1, 3, 5]
mark_counts = collections.Counter(student_marks)
print(mark_counts)

# Counter({4: 4, 6: 3, 1: 3, 2: 2, 7: 2, 3: 2, 5: 2})

#Один з найпопулярніших методів Counter - це most_common(), який повертає список елементів та їх частоту, починаючи з тих які зустрічаються найчастіше. Цей метод може бути надзвичайно корисним для аналізу даних, коли важливо визначити, які елементи зустрічаються найчастіше.

import collections

student_marks = [4, 2, 4, 6, 7, 4, 2 , 3, 4, 5, 6, 6, 7 , 1, 1, 1, 3, 5]
mark_counts = collections.Counter(student_marks)

print(mark_counts.most_common())
print(mark_counts.most_common(1))
print(mark_counts.most_common(2))

# [(4, 4), (6, 3), (1, 3), (2, 2), (7, 2), (3, 2), (5, 2)]
# [(4, 4)]
# [(4, 4), (6, 3)]
from collections import Counter
letter_count = Counter("banana")
print(letter_count)

sentence = "the quick brown fox jumps over the lazy dog"
words = sentence.split()
word_count = Counter(words)

# Виведення слова та його частоти
for word, count in word_count.items():
    print(f"{word}: {count}")

# defaultdict
# Спеціальний словник defaultdict є підкласом словника dict у Python, який входить у модуль collections. Цей тип словника дозволяє призначити значення за замовчуванням для ключів, які ще не існують у словнику.

from collections import defaultdict

# Створення defaultdict з list як фабрикою за замовчуванням
d = defaultdict(list)

# Додавання елементів до списку для кожного ключа
d['a'].append(1)
d['a'].append(2)
d['b'].append(4)

print(d)
# defaultdict(<class 'list'>, {'a': [1, 2], 'b': [4]})

d = defaultdict(int)

# Збільшення значення для кожного ключа
d['a'] += 1
d['b'] += 1
d['a'] += 1

print(d)

words = ['apple', 'zoo', 'lion', 'lama', 'bear', 'bet', 'wolf', 'appendix']
grouped_words = {}

for word in words:
    char = word[0]
    if char not in grouped_words:
        grouped_words[char] = []
    grouped_words[char].append(word)

print(grouped_words)

# {
#     'a': ['apple', 'appendix'],
#     'z': ['zoo'],
#     'l': ['lion', 'lama'],
#     'b': ['bear', 'bet'],
#     'w': ['wolf']
# }

from collections import defaultdict

words = ['apple', 'zoo', 'lion', 'lama', 'bear', 'bet', 'wolf', 'appendix']
grouped_words = defaultdict(list)

for word in words:
    char = word[0]
    grouped_words[char].append(word)

print(dict(grouped_words))
# LIFO
# Створення стеку
def create_stack():
    return []

# Перевірка на порожнечу
def is_empty(stack):
    return len(stack) == 0

# Додавання елементу
def push(stack, item):
    stack.append(item)

# Вилучення елементу
def pop(stack):
    if not is_empty(stack):
        return stack.pop()
    else:
        print("Стек порожній")

# Перегляд верхнього елемента
def peek(stack):
    if not is_empty(stack):
        return stack[-1]
    else:
        print("Стек порожній")

stack = create_stack()
push(stack, 'a')
push(stack, 'b')
push(stack, 'c')

print(peek(stack))  # Виведе 'c'
print(pop(stack))  # Виведе 'c'
# FIFO
# Enqueue - додавання елемента в кінець черги.
# Dequeue - видалення елемента з початку черги.
# Front/Peek - перегляд першого елемента черги без його видалення.
# Is Empty - перевірка, чи черга порожня.
# Size - визначення кількості елементів у черзі.

# В Python, чергу можна реалізувати за допомогою вбудованого типу list, хоча це не завжди найефективніший спосіб через високу вартість операцій Dequeue. Списки у Python реалізовані таким чином, що вибір елемента за індексом відбувається за константний час (дуже швидко) і додавання/видалення елементу з кінця списку теж відбувається дуже швидко. Але ось додавання елементу в будь-яке інше місце в списку змушує Python перерахувати індекси усіх елементів списку до кінця. Для великих списків це може бути дуже невигідно. Ефективнішим варіантом є використання deque з модуля collections в якості черги.
# 

from collections import deque

# Створення черги
queue = deque()

# Enqueue: Додавання елементів
queue.append('a')
queue.append('b')
queue.append('c')

print("Черга після додавання елементів:", list(queue))

# Dequeue: Видалення елемента
print("Видалений елемент:", queue.popleft())

print("Черга після видалення елемента:", list(queue))

# Peek: Перегляд першого елемента
print("Перший елемент у черзі:", queue[0])

# IsEmpty: Перевірка на порожнечу
print("Чи черга порожня:", len(queue) == 0)

# Size: Розмір черги
print("Розмір черги:", len(queue))

# Черга після додавання елементів: ['a', 'b', 'c']
# Видалений елемент: a
# Черга після видалення елемента: ['b', 'c']
# Перший елемент у черзі: b
# Чи черга порожня: False
# Розмір черги: 2

# Двостороння черга deque

# Двостороння черга, або Deque (скорочення від "double-ended queue"), є типом структури даних, яка дозволяє вставляти та видаляти елементи з обох кінців. Ця гнучкість робить Deque особливо корисною у багатьох сценаріях програмування.

# На відміну від звичайної черги, де елементи можна додавати та видаляти лише з одного кінця, Deque дозволяє проводити операції на обох кінцях. Тому deque з модуля collections реалізований таким чином, що операції додавання та видалення елементів є дуже ефективними, навіть для великих наборів даних.

# Основні методи deque
# append(x) - додає елемент x в кінець черги.
# appendleft(x) - додає елемент x на початок черги.
# pop() - видаляє та повертає елемент з правого кінця черги. Якщо черга порожня, викидає виняток IndexError.
# popleft() - видаляє та повертає елемент з лівого кінця черги. Якщо черга порожня, викидає виняток IndexError.

from collections import deque

# Створення пустої двосторонньої черги
d = deque()

# Додаємо елементи в чергу
d.append('middle')  # Додаємо 'middle' в кінець черги
d.append('last')    # Додаємо 'last' в кінець черги
d.appendleft('first')  # Додаємо 'first' на початок черги

# Виведення поточного стану черги
print("Черга після додавання елементів:", list(d))

# Видалення та виведення останнього елемента (з правого кінця)
print("Видалений останній елемент:", d.pop())

# Видалення та виведення першого елемента (з лівого кінця)
print("Видалений перший елемент:", d.popleft())

# Виведення поточного стану черги після видалення елементів
print("Черга після видалення елементів:", list(d))

# Черга після додавання елементів: ['first', 'middle', 'last']
# Видалений останній елемент: last
# Видалений перший елемент: first
# Черга після видалення елементів: ['middle']

from collections import deque

d = deque(maxlen=5)
for i in range(10):
    d.append(i)

print(d)

# deque([5, 6, 7, 8, 9], maxlen=5)

#Як видно з прикладу, нові елементи витісняють старіші, але розмір залишається незмінним. В усьому іншому deque веде себе точно як список Python.

tasks = [
    {"type": "fast", "name": "Помити посуд"},
    {"type": "slow", "name": "Подивитись серіал"},
    {"type": "fast", "name": "Вигуляти собаку"},
    {"type": "slow", "name": "Почитати книгу"}
]

# Завдання, визначені як "fast", повинні виконуватися в першу чергу, тому вони мають більший пріоритет. Натомість "slow" завдання можуть зачекати і ми додаємо їх в кінець черги, виконуючи після всіх швидких завдань.

# Ініціалізація черги завдань
task_queue = deque()

# Розподіл завдань у чергу відповідно до їх пріоритету
for task in tasks:
    if task["type"] == "fast":
        task_queue.appendleft(task)  # Додавання на високий пріоритет
        print(f"Додано швидке завдання: {task['name']}")
    else:
        task_queue.append(task)  # Додавання на низький пріоритет
        print(f"Додано повільне завдання: {task['name']}")

# Виконання завдань
while task_queue:
    task = task_queue.popleft()
    print(f"Виконується завдання: {task['name']}")

# Контроль точності обчислень decimal
# Щоб контролювати точність обчислень більш явно, у Python є пакет decimal. Decimal — це клас у модулі decimal, який забезпечує точну арифметику з дійсними числами, вирішуючи деякі проблеми, які виникають при використанні типу float. Він особливо корисний для точних обчислень, таких як фінансові розрахунки, де помилки округлення можуть призвести до значних проблем.

from decimal import Decimal

print(Decimal("0.1") + Decimal("0.2") == Decimal("0.3"))
print(Decimal("0.1") + Decimal("0.2"))

#Об'єкти Decimal поводяться так само, як float, але їх і не можна використовувати в одному виразі разом. Виконання виразу на кшталт Decimal("0.1") + 0.2 призведе до помилки.

from decimal import getcontext
getcontext().prec = 4

from decimal import Decimal, getcontext

getcontext().prec = 6
print(Decimal("1") / Decimal("7"))

getcontext().prec = 8
print(Decimal("1") / Decimal("7"))

# 0.142857
# 0.14285714

# ☝ Визначення значущих цифр:

# Усі ненульові цифри є значущими: 1, 2, 3, 4, 5, 6, 7, 8, 9.
# Нулі між ненульовими цифрами значущі: 102, 2005, 50009.
# Провідні нулі ніколи не бувають значущими: 0.02; 001.887; 0.000515.
# В числі з десятковою або без десяткової крапки знаходяться знакові нулі (праворуч від останньої ненульової цифри) за умови, якщо вони обґрунтовані точністю їх використання: 389.000; 2.02000; 5.400; 57.5400. 
from decimal import Decimal, getcontext

getcontext().prec = 6
print(Decimal("233") / Decimal("7"))

# Виведення буде саме 6 значущих цифр.

# 33.2857

# Якщо ми потребуємо саме округлення чисел, нам необхідно використовувати метод quantize. Метод quantize використовується для встановлення точності числа Decimal, заснованої на іншому числі Decimal, яке використовується як шаблон.

from decimal import Decimal, ROUND_DOWN

# Вихідне число Decimal
number = Decimal('3.14159')

# Встановлення точності до двох знаків після коми
rounded_number = number.quantize(Decimal('0.00'), rounding=ROUND_DOWN)

print(rounded_number)

# Decimal дозволяє вибирати різні режими округлення. Згідно з офіційною документацією Python, розглянемо основні режими:

# ROUND_FLOOR число завжди округляє до найближчого меншого значення, незалежно від знаку числа.
# ROUND_CEILING число завжди округляє до найближчого більшого значення, незалежно від знаку числа.
# ROUND_HALF_DOWN числа округлюються до найближчого значення. У випадку, коли число знаходиться точно посередині між двома можливими варіантами округлення (наприклад, 2.5, де можливі варіанти — 2 або 3), число округляється вниз, тобто до найближчого меншого значення.
# ROUND_HALF_UP числа округлюються до найближчого значення. Проте у випадку нічиї (коли число знаходиться точно посередині між двома варіантами), число округляється вгору, тобто до найближчого більшого значення.
# ROUND_UP число округляється від нуля. Це означає, що додатні числа округлюються до більшого, а від'ємні - до меншого за модулем значення.
# ROUND_DOWN число округляється до нуля. Тобто додатні числа округлюються до меншого, а від'ємні - до більшого за модулем значення.
# ROUND_HALF_EVEN числа округлюються до найближчого числа. Цей режим, також відомий як "банківське округлення", округлює число до найближчого значення, але у випадку нічиї (коли число точно посередині між двома варіантами), воно округляється до найближчого парного цілого числа. Наприклад, як 2.5 округлиться до 2, а 3.5 - до 4. Цей метод зменшує сукупну помилку при серії округлень.
# За замовчуванням округлення описується константою ROUND_HALF_EVEN

import decimal
from decimal import Decimal
 
number = Decimal("1.45")

# Округлення за замовчуванням до одного десяткового знаку
print("Округлення за замовчуванням ROUND_HALF_EVEN:", number.quantize(Decimal("0.0")))

# Округлення вверх при нічиї (ROUND_HALF_UP)
print("Округлення вгору ROUND_HALF_UP:", number.quantize(Decimal("0.0"), rounding=decimal.ROUND_HALF_UP))

# Округлення вниз (ROUND_FLOOR)
print("Округлення вниз ROUND_FLOOR:", number.quantize(Decimal("0.0"), rounding=decimal.ROUND_FLOOR))

# Округлення вверх (ROUND_CEILING)
print("Округлення вгору ROUND_CEILING:", number.quantize(Decimal("0.0"), rounding=decimal.ROUND_CEILING))

# Округлення до трьох десяткових знаків за замовчуванням
print("Округлення до трьох десяткових знаків:", Decimal("3.14159").quantize(Decimal("0.000")))

# Округлення за замовчуванням ROUND_HALF_EVEN: 1.4
# Округлення вгору ROUND_HALF_UP: 1.5
# Округлення вниз ROUND_FLOOR: 1.4
# Округлення вгору ROUND_CEILING: 1.5
# Округлення до трьох десяткових знаків: 3.142

# Генератори

# Функції — це ізольовані набори інструкцій з однією точкою входу і однією точкою виходу. Іншими словами, коли ви викликаєте функцію, то інтерпретатор виконає увесь її код від початку і до кінця при кожному виклику.

# Один із способів створити генератор у Python — це створити особливу функцію з декількома точками входу. Для цього використовується ключове слово yield.

# Оператор yield поводиться схожим чином з return, повертає управління потоком виконання програмою з тіла функції. Але, на відміну від return, yield при наступному зверненні не розпочинає виконання функції з початку, а продовжує з місця зупинки функції.

def my_generator():
    yield 1
    yield 2
    yield 3

gen = my_generator()

# Використання next()
print(next(gen))  # Виведе 1
print(next(gen))  # Виведе 2
print(next(gen))  # Виведе 3

# Один з корисних випадків застосування генератору, це ітерація по файлу. Генератор дозволяє нам оброблювати дуже великі файли і при цьому економити пам'ять.



def read_lines(file_path):
    with open(file_path, 'r', encoding="utf-8") as file:
        for line in file:
            yield line.strip()

# Використання генератора для читання рядків з файлу
for line in read_lines("my_file.txt"):
    print(line)

# Перевага такого підходу в тому, що завдяки лінивій обробці, генератор читає рядки один за одним, не завантажуючи весь файл у пам'ять. Це особливо корисно при роботі з великими файлами.

# Генератор в Python - це об'єкт, який використовується для лінивої (on-demand) генерації даних та дозволяє нам оголошувати функцію, яка може бути використана в циклі.
# Генератор створюється за допомогою функції, яка повертає послідовність елементів один за одним, використовуючи yield, а не return.
# Генератор виробляє елементи "на льоту" і обробляє один елемент за раз. Це дуже ефективно з точки зору використання пам'яті, особливо для великих даних. Коли генератор виробляє значення, його стан "заморожується", і виконання може бути продовжене з цього моменту при наступному виклику.
# Генератори можна перебирати в циклі for або вручну за допомогою функції next().
