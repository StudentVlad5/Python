# Введення (отримання даних)
ім_я = input("Введіть ваше ім'я: ")

# Перетворення (обробка даних)
вітання = f"Привіт, {ім_я}!"

# Виведення (виведення даних)
print(вітання)

# Вивід даних
print("Привіт", end=" ") # cursor doesn't move
# Введення даних
a = input("Рядок запрошення: ")
# Приведення типів
age = input("How old are you? ")
age = int(age)
pi = float('3.14')
pi_str = str(3.14)
age_str = str(29)
# Зазвичай числове значення 0, порожні колекції ([], (), {}) та None перетворюються на False. Усе інше — на True.
bool(0)  # False
bool(1)  # True

a = float(input("Введіть сторону квадрата a: "))
P = 4 * a
print(f"Периметр квадрата дорівнює {P}")

# Приклад. Для кава-брейків на конференції закуплено круасани, стаканчики та пакунки кави. Ціна круасана — $1.04, ціна стаканчика — $0.34, ціна пакунка кави — $4.42. Потрібно класти програму, яка обчислює, скільки повних доларів пішло на закупівлю їжі для кава-брейків і яка її повна вартість у центах.

# Встановлюємо ціни на продукти
price_per_croissant = 1.04
price_per_glass = 0.34
price_per_coffee_pack = 4.42

# Кількість кожного продукту
num_croissants = int(input("Введіть кількість круасанів: "))
num_glasses = int(input("Введіть кількість склянок: "))
num_coffee_packs = int(input("Введіть кількість упаковок кави: "))

# Обчислення загальної вартості
total_cost = num_croissants * price_per_croissant + \
             num_glasses * price_per_glass + \
             num_coffee_packs * price_per_coffee_pack

# Визначаємо кількість повних доларів і центів
total_dollars = int(total_cost)
total_cents = int(total_cost * 100)

# Вивід результату
print(f"Загальна вартість у повних доларах: {total_dollars} доларів")
print(f"Загальна вартість у центах: {total_cents} центів")

# Тут символ \ використовується в кінці рядка для вказівки на те, що вираз продовжується на наступному рядку. Це дозволяє зробити код більш організованим і легким для читання, особливо коли працюєш із довгими виразами.

# Таким чином, основна відмінність між / і // полягає в тому, що перший завжди повертає float, навіть якщо ділення виходить націло, тоді як другий може повертати як int, так і float, залежно від типів операндів.

вітання="dfdfdsffs"
print("вітання", вітання)

num = 15  # приклад значення для num
if num > 10:
    print("num більше за 10")
else:
    print("num не більше за 10")
x = int(input('Введіть число: '))
if x % 2 == 0:
    print("Число x є парним.")
else:
    print("Число x є непарним.")

for i in range(1, 10):
    if i % 2 == 0:
        print(f"{i} є парним числом.")
    else:
        print(f"{i} є непарним числом.")

# Зараз ми розглянемо три ключові функції Python, які забезпечують потужні і гнучкі способи для ітерації, або повторення певних дій: range, enumerate та zip.

# Функція range важлива для створення послідовностей чисел, які ви можете використовувати у циклах. Вона надзвичайно корисна, коли вам потрібно виконати дію певну кількість разів або ітерувати через послідовність чисел.
# Коли вам потрібно отримати доступ не тільки до значення з ітерованої колекції, але до її індексу, тут функція enumerate стає незамінним помічником. Ця функція дозволяє вам легко отримувати доступ до індексу кожного елементу під час ітерації.
# Функція zip використовується для одночасної ітерації по кількох колекціях. Якщо вам потрібно комбінувати дані з різних джерел або виконувати операції, які залежать від декількох пов'язаних колекцій, zip дозволяє це зробити легко та елегантно.

# range(stop): Створює послідовність чисел від 0 до stop - 1.
# range(start, stop): Генерує числа від start до stop - 1.
# range(start, stop, step): Створює числа від start до stop - 1, з кроком step.

some_list = ["apple", "banana", "cherry"]
for index, value in enumerate(some_list):
    print(index, value)
# 0 apple
# 1 banana
# 2 cherry

list1 = ["зелене", "стигла", "червоний"]
list2 = ["яблуко", "вишня", "томат"]
for number, letter in zip(list1, list2):
    print(number, letter)

# for key in numbers.keys():
    # print(key)

# for val in numbers.values():
#     print(val)

# for key, value in numbers.items():
#     print(key, value)

val = 'a'
try:
    val = int(val)
except ValueError:
    print(f"val {val} is not a number")
else:
    print(val > 0)
finally:
    print("This will be printed anyway")

# SyntaxError — синтаксична помилка.

# IndentationError — помилка, яка виникає, якщо у виділенні блоків інструкцій пробілами допущена помилка.

# TabError виникає, якщо в одному файлі використовувати пробіли і табуляції для виділення блоків інструкцій.

# TypeError виникає, коли операція зі змінною цього типу неможлива.

# Ця функція приймає один символ і повертає його код ASCII. Наприклад, ord('A')
def string_to_codes(string: str) -> dict:
    # Ініціалізація словника для зберігання кодів
    codes = {}  
    # Перебір кожного символу в рядку
    for ch in string:  
        # Перевірка, чи символ вже є в словнику
        if ch not in codes:
            # Додавання пари символ-код в словник  
            codes[ch] = ord(ch)  
    return 

# Коли ми перебуваємо всередині функції func_inner, змінна x, визначена у першому рядку функції func_outer, знаходиться в enclosing області видимості для неї. Якщо ми захочемо використати саме цю змінну x, ми повинні оголосити її nonlocal x всередині функції func_inner. Це означає, що змінна x, яку вона буде змінювати, є не локальною для func_inner, а знаходиться на більш високому рівні — в нашому випадку, в func_outer. Тому, коли func_inner змінює x на 5, ця зміна відображається на x в func_outer.

# Для того, щоб змінити глобальну змінну всередині функції, необхідно використовувати ключове слово global. Це вказує Python, що змінна не є локальною, а належить до глобальної області видимості. Без застосування зарезервованого слова global неможливо присвоїти значення змінній, визначеній за межами функції.

def say(message, times=1):
    print(message * times)

say('Привіт') 
say('Світ', 5)

# Параметр *args. Він дозволяє функції приймати довільну кількість позиційних аргументів. Аргументи, передані функції, зберігаються у вигляді кортежу.
# Параметр **kwargs. Він дозволяє функції приймати довільну кількість ключових аргументів. Але аргументи, передані функції, зберігаються вже у вигляді словника.

# Проте ніхто не забороняє параметри *args та **kwargs використовувати разом у функції, що дозволяє їй приймати довільну кількість як позиційних, так і ключових аргументів. Це робить функцію надзвичайно гнучкою. Головне пам'ятати, що коли ви використовуєте обидва ці параметри разом, *args має йти перед **kwargs. Тоді параметр *args збере всі позиційні аргументи в кортеж, а **kwargs збере всі ключові аргументи в словник.

message = "Never argue with stupid people, they will drag you down to their level and then beat you with experience."
search = "r"
result = message.count(search)
print("result", result)

a = "\u0030" #unicode for 0
b = "\u0047" #unicode for G
print(a.isdecimal()) #True
print(b.isdecimal()) #False

def factorial(n):
    if n < 2:
        return 1
    else:
        return n * factorial(n - 1)


def number_of_groups(n, k):
     return factorial(n) // (factorial(n - k) * factorial(k))
    

print("number_of_groups", number_of_groups(50,7))
print("not True", not True)


