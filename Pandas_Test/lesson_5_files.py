'''
Функція open() повертає файловий об'єкт, який далі може бути використаний для читання з файлу або запису в нього.

open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)
Параметри:

file - шлях до файлу у вигляді рядка. Це може бути повний шлях або шлях відносно поточного каталогу виконання.
mode (необов'язковий) - режим, в якому буде відкрито файл. Ось основні режими які ми будемо використовувати:
'r' - читання (за замовчуванням). Файл має існувати.
'w' - запис. Створює новий файл або перезаписує, що вже існує.
'a' - додавання. Дописує в кінець файлу, не перезаписуючи його.
'b' - бінарний режим (може бути використаний разом з іншими, наприклад 'rb' або 'wb').
'+' - оновлення (читання та запис).
buffering (необов'язковий) - визначає буферизацію: 0 для вимкненої, 1 для включеної буферизації рядків, більше 1 для вказання розміру буфера у байтах.
encoding (необов'язковий) - ім'я кодування, яке буде використовуватися для кодування або декодування файлу.
errors (необов'язковий) - вказує, як обробляти помилки кодування.
newline (необов'язковий) - контролює, як обробляються нові рядки.
closefd (необов'язковий) - має бути True (за замовчуванням); якщо вказано False, файловий дескриптор не буде закритий.
opener (необов'язковий) - визначає спеціальну функцію для відкриття файлу.

'''

fh = open('test.txt', 'w')
symbols_written = fh.write('hello!')
print(symbols_written) # 6
fh.close()

# В цьому прикладі ми створили (або перезаписали, якщо він вже існував) файл test.txt для запису та записали туди рядок 'hello!' завдовжки 6 символів. Для запису даних у файл ми використали метод write у об'єкта fh. Цей метод повертає кількість записаних у файл символів - в нашому випадку число 6.

# Парний до нього метод — це метод read, який дозволяє прочитати деяку кількість символів із файлу.

fh = open('test.txt', 'w+')
fh.write('hello!')
fh.seek(0)

first_two_symbols = fh.read(2)
print(first_two_symbols)  # 'he'

fh.close()

fh = open('test.txt', 'w')
fh.write('hello!')
fh.close()

fh = open('test.txt', 'r')
while True:
    symbol = fh.read(1)
    if len(symbol) == 0:
        break
    print(symbol)

fh.close()

# Ще є зручний спосіб читати файл порядково, по одному рядку за раз, для цього можна скористатися методом readline:

fh = open('test.txt', 'w')
fh.write('first line\nsecond line\nthird line')
fh.close()

fh = open('test.txt', 'r')
while True:
    line = fh.readline()
    if not line:
        break
    print(line)

fh.close()
# Та аналогічний метод readlines, який читає увесь файл повністю, але повертає список рядків, де елемент списку — це один рядок з файлу.
fh = open('test.txt', 'w')
fh.write('first line\nsecond line\nthird line')
fh.close()

fh = open('test.txt', 'r')
lines = fh.readlines()
print(lines)

fh.close()

# ['first line\n', 'second line\n', 'third line']

fh = open("test.txt", "w")
fh.write("first line\nsecond line\nthird line")
fh.close()

fh = open("test.txt", "r")
lines = [el.strip() for el in fh.readlines()]
print(lines)

fh.close()

# Тепер повернемось до детального розгляду метода seek. Python дає можливість управляти положенням курсора (вказівника) у файлі та довільно переміщатися файлом за допомогою методу seek. Цей метод приймає один аргумент — це кількість символів, на які потрібно змістити курсор у файлі:

# Щоб дізнатися положення курсора в цей момент, можна скористатися методом tell, він повертає позицію (номер) символу з початку файлу, де зараз знаходиться курсор.

fh = open("test.txt", "w+")
fh.write("hello!")

position = fh.tell()
print(position)  # 6

fh.seek(1)
position = fh.tell()
print(position)  # 1

fh.read(2)
position = fh.tell()
print(position)  # 3

fh.close()

'''
# Менеджер контексту
Застосунок може виконати багато операцій між відкриттям та закриттям файлу. В будь-якому місці може статися помилка та застосунок завершиться аварійно, не повернувши файловий дескриптор системі. Така поведінка, як вже згадувалося, небажана і може призводити до втрати даних.
Щоб уникнути цього, можна взяти блок коду, в якому відбувається робота з файлом, у блок try ... except:
'''
fh = open('text.txt', 'w')
try:
    # Виконання операцій з файлом
    fh.write('Some data')
finally:
    # Закриття файлу в блоку finally гарантує, що файл закриється навіть у разі помилки
    fh.close()

# Для покращення читабельності коду при збереженні функціоналу можна скористатися менеджером контексту with. Менеджер контексту в Python - це спосіб використання ресурсів, який автоматично забезпечує правильне закриття файлу, незалежно від того, чи виникла помилка чи ні. Це робить код не тільки більш читабельним, але й безпечнішим.

with open('text.txt', 'w') as fh:
    # Виконання операцій з файлом
    fh.write('Some data')
# Файл автоматично закриється після виходу з блоку with
with open("test.txt", "w") as fh:
    fh.write("first line\nsecond line\nthird line")

with open("test.txt", "r") as fh:
    lines = [el.strip() for el in fh.readlines()]

print(lines)
'''
Робота з не текстовими файлами у Python
Поки що ми розглядали тільки роботу з текстовими фалами в кодуванні UTF-8. Це режим роботи з файлами за замовчуванням. Якщо ж потрібно працювати не з текстовими файлами, то можна вказати режим відкриття файлів як b, скорочено від bytes. У такому режимі ви отримаєте файловий об'єкт для роботи з файлом в режимі байт-рядків.

'''

with open('raw_data.bin', 'wb') as fh:
    fh.write(b'Hello world!')

    '''
    В цьому прикладі ми відкрили файл raw_data.bin у режимі для запису "сирих" даних, на що вказує значення wb. В цьому режимі у файл можна писати тільки байт-рядки або байт-масиви.

У режимі роботи з "сирими" даними можна відкрити та прочитати вміст будь-якого файлу. Замість терміну “сирі” дані, можуть також казати двійкові дані або бінарні дані.
Отже є ще один контейнер, з яким ми раніше не працювали. Це bytes — байтові рядки.
Байтові рядки в Python є важливим інструментом для роботи з двійковими даними. Вони дозволяють зберігати та обробляти байти, які є основними будівельними блоками даних у комп'ютерах.
У пам'яті комп'ютера дані зберігаються як послідовності байтів. Будь-яка інформація - текст, зображення, звук, тощо - може бути представлена у вигляді байтів. Відповідно, будь-які дані можна представити у вигляді послідовності байтів.
Щоб працювати з послідовністю байтів у Python є вбудовані типи даних байт-рядків
bytes - незмінний тип, що використовують для представлення байтів.
bytearray - змінний тип, що дозволяє модифікувати байти після їх створення.
Застосування байтових даних досить поширене. Наприклад байтові рядки важливі для роботи з мережевими протоколами (наприклад, TCP/IP), послідовними портами, telnet та іншими протоколами, де дані передаються як потік байтів.
За своєю суттю байт-рядки або простіше байти — це звичайні рядки, але для запису одного символу використовується суворо один байт. Це відрізняється від звичайних рядків, де символи (особливо в Unicode) можуть займати більше одного байта.
Але що таке байт та біт насправді для комп'ютера? Розглянемо це більше детально.
Біт (скорочено від "binary digit" або "двійкова цифра") є основною одиницею інформації в обчислювальній техніці та цифровій комунікації. Біт може мати одне з двох значень: 0 або 1. Ви можете думати про біт, як про відповідь на просте питання: "так/ні" або "вимкнено/увімкнено".
Байт - це послідовність з 8 бітів, яка є стандартною одиницею вимірювання кількості інформації в комп'ютерах. Один байт може представляти 256 різних станів. Від 00000000 до 11111111 у двійковому форматі або від 0 до 255 десятеричному, що дозволяє кодувати широкий спектр інформації, наприклад, символи тексту, частини зображень або звуку.
У комп'ютерах кожен символ у тексті (наприклад, літера або цифра) зазвичай кодується одним байтом. Наприклад, у кодуванні ASCII символ 'A' представляється як 01000001. Усі дані на комп'ютері зберігаються у вигляді байтів. Наприклад, текстовий файл розміром у 1 кілобайт займає 1024 байти в пам'яті комп'ютера. Коли дані передаються через інтернет мережу, вони також розбиваються на байти.
Звісно не всі програмісти працюють напряму з бітами та байтами, але розуміти це потрібно. Оскільки біти та байти є фундаментом всіх цифрових систем. Вони дозволяють комп'ютерам представляти та обробляти всі види інформації, від простих документів до складних відео та звуків.

    '''
# Для байт-рядків застосовуються ті самі обмеження і правила, що і для звичайних рядків. Наприклад, ви можете використовувати методи upper(), startswith(), index(), find() і так далі.

s = b'Hello!'
print(s[1])  # Виведе: 101 (це ASCII-код символу 'e')

# ASCII широко використовується для зберігання та обробки тексту в комп'ютерах, особливо для англомовного контенту. Мережеві протоколи та комунікаційні інтерфейси часто використовують ASCII для передачі текстової інформації. Але ASCII не підтримує символи багатьох мов, що не використовують латинський алфавіт. Через це були розроблені інші формати кодування, такі як UTF-8, які підтримують широкий спектр мовних символів та інших знаків. Про нього ми розповімо окремо трохи далі.

byte_string = b'Hello world!'

# Для перетворення рядка у байт-рядок можна скористатися методом рядків encode. Коли ви використовуєте .encode(), ви перетворюєте рядок у байтову послідовність. Метод .encode() важливий, оскільки він дозволяє стандартизувати рядок для операцій, які вимагають однакового представлення символів, незалежно від системи або платформи.
byte_str = 'some text'.encode()
print(byte_str)
'''
У byte_str буде записана послідовність байтів b'some text'.
Синтаксис:
str.encode(encoding="utf-8", errors="strict")

encoding - вказує метод кодування. По замовчуванню використовується 'utf-8', який підтримує велику кількість символів з різних мов.
errors - вказує, як обробляти помилки кодування. Наприклад, 'strict' для викидання виключення у випадку помилки, 'ignore' для ігнорування помилок або 'replace' для заміни неможливих для кодування символів на певний замінник (?).

Ви повинні зрозуміти, що метод .encode() є фундаментальним для роботи з текстовими даними в Python, оскільки він забезпечує зв'язок (місток) між текстом (рядками Unicode) та байтами, які можуть бути використані в бінарних операціях або в передачі даних по мережі.
'''

'''
Перетворення чисел у байт-рядки

У Python ви можете перетворювати числа у байт-рядки за допомогою вбудованої функції bytes. Це корисно для роботи з двійковими даними, особливо коли потрібно зберігати або передавати числові значення у форматі, оптимізованому для обробки на низькому рівні.

В один байт поміщається число від 0 до 255 включно, відповідно можна перетворити послідовність чисел від 0 до 255 у байт-рядок за допомогою функції bytes:
'''

# Перетворення списку чисел у байт-рядок
numbers = [0, 128, 255]
byte_numbers = bytes(numbers)
print(byte_numbers)  # Виведе байтове представлення чисел

# Тут використовується шістнадцятковий формат для зручного відображення байтів. Символ \x є індикатором шістнадцяткового запису кожного байта.

# Щоб перевірити правильність представлення, можна скористатися вбудованою функцією hex, яка перетворить ціле число в рядок — представлення числа в шістнадцятковій формі:

for num in [127, 255, 156]:
  print(hex(num))

#   В такому вигляді перші два символи 0x вказують на шістнадцяткову форму запису .

'''
Кодування рядків (ASCII, UTF-8, CP1251)

Перші комп'ютери для роботи з текстом використовували так зване ASCII кодування. У цьому кодуванні для запису одного символу використовується один байт.
Зручність цього кодування в тому, що будь-які дані на комп'ютері можна спробувати представити у вигляді тексту в цьому кодуванні. ASCII містить 256 символів. Це не дуже багато і деякий час цього було достатньо. Але з часом алфавіту з 256 символів стало мало, виникла необхідність додати все більше символів (кирилиця, діакритичні знаки, коди валют, ієрогліфи тощо). Щоб задовольнити потребу у додаванні нових символів, придумали використати кодування, де більше одного байту на символ. Python за замовчуванням використовує UTF-8, в якій один символ може займати від 1 до 4 байт, і всього в алфавіті може бути до 1 112 064 знаків. Це не єдине кодування, на різних платформах можуть бути присутні власні, наприклад CP-1251 (кирилиця на ОС сімейства Windows), UTF-16, UTF-32 та інші.
Щоб дізнатися, якому елементу в UTF-8 відповідає символ, є функція ord (від order).
'''
# Щоб дізнатися, якому елементу в UTF-8 відповідає символ, є функція ord (від order).
ord('a')  # 97
# Зворотна операція, коли потрібно дізнатися, який символ закодований числом, наприклад 100, є функція chr (скорочено від character):
chr(128)  # 'd'

s = "Привіт!"

utf8 = s.encode()
print(f"UTF-8: {utf8}")

utf16 = s.encode("utf-16")
print(f"UTF-16: {utf16}")

cp1251 = s.encode("cp1251")
print(f"CP-1251: {cp1251}")

s_from_utf16 = utf16.decode("utf-16")
print(s_from_utf16 == s)
# UTF-8: b'\xd0\x9f\xd1\x80\xd0\xb8\xd0\xb2\xd1\x96\xd1\x82!'
# UTF-16: b'\xff\xfe\x1f\x04@\x048\x042\x04V\x04B\x04!\x00'
# CP-1251: b'\xcf\xf0\xe8\xe2\xb3\xf2!'
# True

# Спроба перетворити байт-рядок в неправильному кодуванні, призводить або до помилки, або до досить непередбачуваного результату:

print(b'Hello world!'.decode('utf-16'))

# А тепер до важливого, навіщо нам знати про інші стандарт, якщо зараз все в UTF-8. При роботі з файлами в операційній системі Windows часто виникає проблема, пов'язана зі стандартним кодуванням. Windows за замовчуванням використовує кодування CP-1251 (також відоме як Windows-1251), яке є стандартним для багатьох країн, де використовується кирилиця. Це кодування істотно відрізняється від UTF-8, яке є універсальним і підтримує широкий спектр символів з різних мов. А нагадаємо, що стандарт зараз всюди це саме UTF-8.
# Коли файл зберігається в кодуванні, відмінному від UTF-8, і потім відкривається у програмі, яка очікує UTF-8 (або навпаки), це може призвести до неправильного відображення тексту. Символи, які не відповідають стандарту кодування, можуть відображатися як нерозпізнані знаки або викликати помилки при читанні файлу.
# Щоб уникнути проблем з кодуванням, особливо при роботі з міжнародними текстами або в середовищах з різними налаштуваннями кодування, рекомендується завжди явно вказувати кодування UTF-8 під час відкриття файлів у Python. Це можна зробити за допомогою параметра encoding у функції open().
# Відкриття текстового файлу з явним вказівкам UTF-8 кодування
# with open('example.txt', 'r', encoding='utf-8') as file:
#     content = file.read()
#     print(content)

# Масив байтів

# Робота з рядками обмежена тим, що рядки і байт-рядки незмінні. Якщо потрібно замінити навіть один символ, потрібно, по суті, створити копію початкового рядка з єдиним відмінним символом. Щоб зменшити накладні витрати при роботі з "сирими" даними, в Python є такий контейнер як bytearray.

byte_array = bytearray(b'Kill Bill')
byte_array[0] = ord('B')
byte_array[5] = ord('K')
print(byte_array)

# bytearray(b'Bill Kill')

# Хоча bytearray сприймається як послідовність чисел, його можна легко перетворити в рядок за допомогою методу decode(), вказавши потрібне кодування.
byte_array = bytearray(b"Hello World")
string = byte_array.decode("utf-8")
print(string)  # Виведе: 'Hello World'

# bytearray особливо корисний при обробці бінарних даних, наприклад, при читанні файлів у бінарному режимі, обробці мережевих пакетів, або при роботі з образами даних у пам'яті.

'''
Порівняння рядків

Принцип порівняння рядків, з перетворенням їх у єдиний регістр, використовується для забезпечення нерозрізнення регістру при порівнянні. Це особливо корисно, коли порівняння повинно бути незалежним від того, чи введено рядок у верхньому, нижньому чи змішаному регістрі.

Основні кроки процесу порівняння наступні.
Перше, це перетворення рядків у єдиний регістр. Це може бути або перетворення всіх символів рядка у нижній регістр за допомогою методу .lower(), або у верхній регістр за допомогою .upper().

Далі сама операція порівняння рядків. Після перетворення обох рядків у однаковий регістр, вони порівнюються. Якщо рядки однакові після перетворення, вони вважаються еквівалентними у контексті нерозрізнення регістру.
'''

string1 = "Hello World"
string2 = "hello world"
if string1.lower() == string2.lower():
    print("Рядки однакові")
else:
    print("Рядки різні")
"""
Коли використовують саме таку техніку порівняння рядків? При пошуку або фільтрації даних, де важливо ігнорувати різницю у регістрі наприклад, пошук користувача за ім'ям в базі даних. У веб-застосунках, для забезпечення консистентного порівняння введених даних наприклад, при вході в систему або пошуку на сайті.

Але порівняння рядків у Python може давати неоднозначний результат внаслідок того, що в UTF-8 кодуванні один і той самий символ можна представити декількома кодами, наприклад, символ 'ê' можна представити кодом U+00EA, або як послідовність двох кодів U+0065 та U+0302. З цієї причини порівняння одного і того самого символу може повернути False через відмінності у записі.

Щоб розв'язати цю проблему при роботі з не ASCII символами для порівняння рядків, їх необхідно нормалізувати за допомогою методу casefold, який повертає рядок, де всі символи у нижньому регістрі і без неоднозначностей, коли будь-який символ матиме тільки одну можливу форму запису.
"""

# Цей метод схожий на lower(), але casefold() є більш радикальним: він призначений для видалення усіх відмінностей у регістрі, які можуть виникати в різних мовах, і тому є більш ефективним для випадків, де потрібно забезпечити нерозрізнення регістру в різноманітних мовах.

text = "Python Programming"
print(text.casefold())

# ле головне застосування casefold() для мов, де одна літера може мати різні верхній та нижній регістри, наприклад, в німецькій мові.

# У німецькій мові, літера "ß" (так званий "sharp S" або "eszett") використовується для позначення специфічного звука, що наближений до подвоєного "ss". Ця літера не має прямого еквіваленту у верхньому регістрі. Традиційно, коли слово, що містить "ß", потрібно написати великими літерами, "ß" перетворюється на "SS".

german_word = 'straße'  # В нижньому регістрі
search_word = 'STRASSE'  # В верхньому регістрі

# Порівняння за допомогою lower()
lower_comparison = german_word.lower() == search_word.lower()

# Порівняння за допомогою casefold()
casefold_comparison = german_word.casefold() == search_word.casefold()

print(f"Порівняння з lower(): {lower_comparison}")
print(f"Порівняння з casefold(): {casefold_comparison}")

# У цьому прикладі, casefold() правильно вважатиме, що рядки "straße" та "STRASSE" еквівалентні, оскільки він враховує особливе перетворення "ß" в "ss". Це може бути важливо у сценаріях, де необхідно забезпечити точне порівняння тексту незалежно від регістру, наприклад, при пошуку у базі даних або при введенні даних користувачем.

# Цей випадок показує, що casefold() є більш ефективним для мов, які мають особливі правила перетворення символів у різних регістрах. У більшості життєвих сценаріїв, особливо при роботі з англійським текстом, lower() і casefold() будуть працювати подібно, але casefold() надає додаткову точність для специфічних мовних випадків.

# ☝ Модуль shutil в Python - це модуль стандартної бібліотеки, який надає ряд функцій для роботи з файлами і колекціями файлів. Цей модуль може бути використаний для копіювання, переміщення, перейменування та видалення файлів і директорій, забезпечуючи високорівневі операції для обробки файлової системи, які є більш зручними, ніж використання базових функцій модуля os.

# Пакет shutil підтримує архіви zip, tar, gz. Для цього він використовує пакети zipfile та tarfile. Ви можете використовувати їх напряму, якщо захочете.

# Функція shutil.make_archive() в Python використовується для створення архівів (наприклад, ZIP або TAR файлів) з заданої директорії. Ця функція є частиною модуля shutil, який надає багато зручних операцій для роботи з файлами, включаючи копіювання та архівування.

# shutil.make_archive(base_name, format, root_dir=None, base_dir=None)

# Параметри:

# base_name - шлях до файлу, де потрібно зберегти архів, без розширення.
# format - формат архіву, наприклад 'zip', 'tar', 'gztar', 'bztar' або 'xztar'.
# root_dir - директорія, з якої буде створено архів. Якщо не вказано, використовується поточна директорія.
# base_dir - директорія всередині архіву, з якої почнеться архівація.
import shutil
shutil.make_archive('example', 'zip', root_dir='my_folder')

# # Створення TAR.GZ архіву
shutil.make_archive('example', 'gztar', root_dir='my_folder')
# У цьому випадку створюється TAR-архів з GZIP-стисненням.

# Звичайно пакет shutil підтримує розпаковування архівів. Функція shutil.unpack_archive() використовується для розпакування архівних файлів, таких як ZIP або TAR, до вказаної директорії. Це зручний спосіб автоматизувати процес розпакування без необхідності вручну використовувати інструменти архівування.

# shutil.unpack_archive(filename, extract_dir=None, format=None)
# Окрім роботи з архівами модуль shutil може ще виконувати наступні високорівневі операції для обробки файлової системи:

# shutil.copy(src, dst) копіює файл з src в dst. Якщо dst є директорією, файл буде скопійований зі своїм поточним іменем у цю директорію.
# shutil.copytree(src, dst) рекурсивно копіює всю директорію src в директорію dst.
# shutil.move(src, dst) переміщує файл або директорію src в dst.
# shutil.rmtree(path) рекурсивно видаляє директорію path.
# shutil.disk_usage(path) повертає статистику використання диска, що містить загальний об'єм, використаний об'єм і вільний об'єм для даного шляху.

# Важливо зазначити, що перед використанням функцій, які модифікують файлову систему, слід з особливою увагою перевіряти шляхи та параметри, щоб уникнути втрати даних. За це відповідає модуль pathlib який ми розглянемо далі.

# Основи модуля pathlib

from pathlib import PurePath

p = PurePath("/usr/bin/simple.jpg")
print("Name:", p.name)  
print("Suffix:", p.suffix) 
print("Parent:", p.parent)
# Name: simple.jpg
# Suffix: .jpg
# Parent: \usr\bin

# У PurePath є ряд корисних методів та атрибутів:

# p.parent вказує на батьківську директорію;
# p.name повертає лише рядок з ім'ям директорі або файлу, на який вказує p;
# p.suffix повертає рядком розширення файлу, на який вказує p, починаючи з крапки;

# Клас Path наслідує всі методи з PurePath і додає методи для виконання операцій, які вимагають доступу до файлової системи, таких як читання, запис файлів, перевірка існування файлів тощо. З класом Path можна створювати нові файли, читати та записувати дані, перевіряти існування шляхів, перелічувати файли у директорії тощо.

from pathlib import Path

p = Path("example.txt")
p.write_text("Hello, world!")
print(p.read_text()) 
print("Exists:", p.exists()) 

# Застосування Path і PurePath залежить від конкретних потреб програми. Для більшості практичних цілей Path буде найкращим вибором, оскільки він надає більш широкий спектр можливостей для роботи з файлами та директоріями.

# Клас Path автоматично адаптується до особливостей шляхів у різних операційних системах. Наприклад, у Windows використовуються зворотні слеші (\), тоді як в Unix-подібних системах (Linux, macOS) - прямі слеші (/).

from pathlib import Path

# Для Unix/Linux
path_unix = Path("/usr/bin/python3")

# Для Windows
path_windows = Path("C:/Users/Username/Documents/file.txt")

# Відносні та абсолютні шляхи

# При роботі з файлами та директоріями у Python важливо розуміти відмінності між відносними та абсолютними шляхами. Модуль pathlib надає інструменти для роботи з обома типами шляхів.

from pathlib import Path

# Перетворення відносного шляху в абсолютний
relative_path = Path("documents/example.txt")
absolute_path = relative_path.absolute()
print(absolute_path)

# Існує метод relative_to() який навпаки, використовується для отримання відносного шляху відносно заданої директорії.

from pathlib import Path

# Перетворення відносного шляху в абсолютний
relative_path = Path("documents/example.txt")
absolute_path = relative_path.absolute()

# current_working_directory = Path("E:\WebDir\Works\Python\python-help-solution\example_for_new_core\l04")
# relative_path = absolute_path.relative_to(current_working_directory)
# print(relative_path)

# Маніпуляція з компонентами шляху

# Клас Path надає зручні методи для маніпулювання компонентами шляху, такі як with_name і with_suffix. Ці методи дозволяють легко змінювати ім'я файлу або його розширення в об'єкті Path.

# Метод with_name замінює ім'я файлу в шляху на нове. Він корисний, коли вам потрібно змінити тільки ім'я файлу, зберігаючи решту шляху незмінною.

from pathlib import Path

# Початковий шлях до файлу
original_path = Path("documents/example.txt")

# Зміна імені файлу
new_path = original_path.with_name("report.txt")
print(new_path)

# Метод with_suffix замінює або додає розширення файлу в шляху. Це корисно, коли потрібно змінити тип файлу або додати розширення до файлу, який його не має.
from pathlib import Path

# Початковий шлях до файлу
original_path = Path("documents/example.txt")

# Зміна імені файлу
new_path = original_path.with_suffix(".md")
print(new_path)

# Щоб фізично змінити ім'я файлу на диску, потрібно використовувати методи для роботи з файловою системою, наприклад, rename. Цей виклик змінить ім'я файлу example.txt на report.txt у директорії documents на диску.

from pathlib import Path

original_path = Path("documents/example.txt")

# Створює новий об'єкт Path з іншим ім'ям файлу
new_path = original_path.with_name("report.txt")
# original_path.rename(new_path)

# Читання та запис файлів
# Модуль pathlib надає кілька методів для читання з файлів та запису в них, що зменшує необхідність використання стандартного модуля open. Але вони не замінюють його, а є доповненням.
# Методи read_text() та write_text() використовуються для читання та запису текстових файлів.
'''
Синтаксис методу read_text()

Path.read_text(encoding=None, errors=None)

Параметри:
encoding - необов'язковий, ім'я кодування, яке використовується для декодування файлу. Якщо не вказано, використовується кодування за замовчуванням.
errors - необов'язково, інструкція, як обробляти помилки декодування.

Синтаксис методу write_text()
Path.write_text(data, encoding=None, errors=None)
data - рядок, який необхідно записати в файл.
encoding - необов'язковий, ім'я кодування, яке використовується для декодування файлу. Якщо не вказано, використовується кодування за замовчуванням.
errors - необов'язково, інструкція, як обробляти помилки декодування.

Як бачимо параметр errors, в обох методах, визначає, як мають бути оброблені ці помилки.
errors='strict'. Це значення за замовчуванням. Якщо виникає помилка декодування, буде викинуто виключення UnicodeDecodeError.
errors='ignore'. Якщо ми хочемо ігнорувати помилки декодування. Частини тексту, що не можуть бути декодовані, будуть просто пропущені.
errors='replace'. Якщо пропускати ми не хочемо, то замінимо неможливі для декодування символи на спеціальний символ заміни, згідно документації символ '?'.
'''
from pathlib import Path

# Створення об'єкту Path для файлу
file_path = Path("example.txt")

# Запис тексту у файл
file_path.write_text("Привіт світ!", encoding="utf-8")

from pathlib import Path

# Створення об'єкту Path для файлу
file_path = Path("example.txt")

# Читання тексту з файлу
text = file_path.read_text(encoding="utf-8")
print(text)

# Методи read_bytes() та write_bytes() використовуються для читання та запису бінарних файлів.

from pathlib import Path

# Створення об'єкту Path для бінарного файлу
file_path = Path("example.bin")

# Бінарні дані для запису
data = b"Python is great!"

# Запис байтів у файл
file_path.write_bytes(data)

from pathlib import Path

# Створення об'єкту Path для бінарного файлу
file_path = Path("example.bin")

# Читання байтів з файлу
binary_data = file_path.read_bytes()
print(binary_data)

# Робота з директоріями

# Модуль pathlib в Python включає функціонал для ефективної роботи з файловою системою, зокрема з директоріями.

# Метод iterdir() використовується для отримання переліку всіх файлів та піддиректорій у вказаній директорії. Цей метод повертає ітератор, який виробляє об'єкти Path для кожного файлу та піддиректорії у директорії, що визначена поточним об'єктом Path.

from pathlib import Path

# Створення об'єкту Path для директорії
directory = Path("./picture")

# Виведення переліку всіх файлів та піддиректорій
# for path in directory.iterdir():
#     print(path)

# Для створення нової директорії використовується метод mkdir().
# Параметри:
# mode - права доступу до директорії, використовуються для Linux і не актуальні для Windows.
# parents - якщо має значення True, створить всі батьківські директорії, які відсутні.
# exist_ok - якщо має значення True, помилка не буде викинута, якщо директорія вже існує.

from pathlib import Path
directory = Path('/my_directory/new_folder')
directory.mkdir(parents=True, exist_ok=True)

# Для видалення директорії використовується метод rmdir(). Він видаляє директорію, але директорія повинна бути порожньою.

from pathlib import Path
directory = Path('/my_directory/new_folder')
directory.rmdir()

# Модуль pathlib також надає декілька методів для перевірки існування та типу файлових об'єктів:

# метод exists() перевіряє, чи існує файл або директорія.
# метод is_dir() перевіряє, чи є об'єкт директорією.
# метод is_file() перевіряє, чи є об'єкт файлом.

from pathlib import Path

path = Path("./picture")

# Перевірка існування
if path.exists():
    print(f"{path} існує")

# Перевірка, чи це директорія
if path.is_dir():
    print(f"{path} є директорією")

# Перевірка, чи це файл
if path.is_file():
    print(f"{path} є файлом")


# Переміщення та копіювання файлів

# Модуль pathlib чудово інтегрується з модулем shutil для виконання операцій копіювання та переміщення файлів. Для копіювання файлів використовується функція shutil.copy() або shutil.copy2().

import shutil
from pathlib import Path

# Вихідний і цільовий файли
source = Path('/path/to/source/file.txt')
destination = Path('/path/to/destination/file.txt')

# Копіювання файла
shutil.copy(source, destination)

# Функція shutil.copy() копіює вміст файлу, але не копіює метадані, тоді як shutil.copy2() копіює і вміст, і метадані.
# Для переміщення файлів використовується функція shutil.move().

import shutil
from pathlib import Path

# Вихідний і цільовий шляхи
source = Path('/path/to/source/file.txt')
destination = Path('/path/to/destination/file.txt')

# Переміщення файла
shutil.move(source, destination)

# Метод stat() повертає інформацію про файл, включаючи його розмір.
from pathlib import Path

file_path = Path("./picture/bot-icon.png")

# Отримання розміру файла
size = file_path.stat().st_size
print(f"Розмір файла: {size} байтів")

# Метод stat() також надає час створення, атрибут st_ctime, та час останньої модифікації файлу, атрибут st_mtime.

# І остання необхідна інформація для роботи з файлами це видалення. Для видалення файлу використовується метод unlink(). Він видаляє файл, на який вказує об'єкт Path.

# Path.unlink(missing_ok=False)

# Параметр missing_ok якщо має значення True, то виключення не буде викинуто, якщо файл не існує. За замовчуванням False, це означає, що буде викинуто виняток FileNotFoundError, якщо файл не існує.

from pathlib import Path

# Створення об'єкту Path для файлу
file_path = Path('/path/to/file.txt')

# Перевірка, чи файл існує, перш ніж видаляти
if file_path.exists():
    file_path.unlink()
    print(f'Файл {file_path} було видалено')
else:
    print(f'Файл {file_path} не існує')

    # Можна також видалити файл без попередньої перевірки його існування, використовуючи параметр missing_ok.

from pathlib import Path
file_path = Path('/path/to/file.txt')
file_path.unlink(missing_ok=True)