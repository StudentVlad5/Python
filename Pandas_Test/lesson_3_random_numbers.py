#  Існують два основних типи випадкових величин: дискретні та неперервні.

# Дискретні випадкові величини: Це такі, які приймають обмежену кількість значень або значення, які можна перелічити. Наприклад, кількість монет, що випали решкою у серії підкидань, є дискретною випадковою величиною.
# Неперервні випадкові величини: Вони можуть приймати будь-яке значення у певному діапазоні. Наприклад, змінна, яка представляє час, необхідний для виконання певної задачі, є неперервною випадковою величиною.

# Для отримання випадкового цілого числа з рівномірного розподілу в інтервалі між a та b включно треба використати метод random.randint(a, b). Він повертає випадкове ціле число N таке, що a <= N <= b:
import random

random.randint(1, 1000)

dice_roll = random.randint(1, 6)
print(f"Ви кинули {dice_roll}")

# Метод random.random() потрібен, щоб отримати випадкове число в інтервалі 0, 1. Він генерує випадкове дійсне число між 0.0 (включно) та 1.0 (не включно):

import random

num = random.random()
print(num)

fill_percentage = random.random() * 100
print(f"Заповнення: {fill_percentage:.2f}%")

# Тут в f рядку з'явилось форматування {fill_percentage:.2f} яке вказує, яким чином відображати змінну fill_percentage. Вираз .2 це кількість знаків після десяткової крапки. У цьому випадку вказано, що потрібно відображати два знаки для дійсного числа. Символ f означає, що число має бути відображене у форматі дійсного числа.

# Метод random.randrange(start, stop[, step]) повертає випадково вибране число з заданого діапазону.

# Наприклад симуляція пострілу по мішені, але необхідно вибрати випадковий номер від 1 до 10, та лише непарні числа:
import random

target = random.randrange(1, 11, 2)
print(f"Ціль: {target}")

# Коли у вас є список об'єктів і вам потрібно перемішати порядок елементів в цьому списку на випадковий, ми використовуємо метод random.shuffle(x), де x - список, який потрібно перемішати
import random
cards = ["Туз", "Король", "Дама", "Валет", "10", "9", "8", "7", "6"]
random.shuffle(cards)
print(f"Перемішана колода: {cards}")

# Якщо потрібно вибрати випадковий елемент зі списку, нам потрібно використати метод random.choice(seq), де seq - послідовність для вибору: список або кортеж.
import random

fruits = ['apple', 'banana', 'orange']
print(random.choice(fruits))

# Щоб вибрати більше чим один випадковий елемент зі списку, нам необхідний метод random.choices()
# random.choices(population, weights=None, cum_weights=None, k=1)
# population - послідовність список, з якої має бути зроблений вибір.
# weights - опціональний список, який вказує ймовірності (ваги) кожного елемента в списку population. Ці ваги визначають, наскільки ймовірно, що конкретний елемент буде обраний. Довжина списку weights має бути дорівнювати довжині списку population.
# cum_weights - теж опціональний список кумулятивних ваг. Якщо він вказаний, то список weights ігнорується. Кумулятивна вага кожного елемента визначається як сума його ваги плюс ваги всіх попередніх елементів.
# k: Кількість елементів для вибору. За замовчуванням k=1.
import random

numbers = [1, 2, 3, 4, 5]
chosen_numbers = random.choices(numbers, k=3)
print(chosen_numbers)

import random

colors = ['червоний', 'зелений', 'синій']
weights = [10, 1, 1]
chosen_color = random.choices(colors, weights, k=1)
print(chosen_color)  

# Якщо виникає необхідність вибрати N елементів зі списку і вони при цьому не повторювалися треба використати метод random.sample(population, k). Він повертає список довжиною k з унікальними елементами, вибраними випадково з population.

import random

participants = ['Анна', 'Богдан', 'Віктор', 'Галина', 'Дмитро', 'Олена', 'Женя', 'Зорян', 'Ігор', 'Йосип']
team = random.sample(participants, 4)
print(f"Команда: {team}")

# Останній корисний метод, який розглянемо це random.uniform(a, b). Метод повертає випадкове дійсне число N, таке що a <= N <= b.
import random

price = random.uniform(50, 100)
print(f"Випадкова ціна: {price:.2f}")

# random.randint(a, b): Отримання випадкового цілого числа з рівномірного розподілу в інтервалі між a та b включно.
# random.random(): Отримання випадкового числа в інтервалі між 0.0 (включно) та 1.0 (не включно).
# random.randrange(start, stop, step): Отримання випадкового числа з заданого діапазону, з можливістю вказати крок між значеннями.
# random.shuffle(x): Перемішування порядку елементів у списку x.
# random.choice(seq): Вибір випадкового елемента з послідовності seq (списку або кортежу).
# random.choices(population, weights=None, cum_weights=None, k=1): Генерація випадкової вибірки з можливістю зазначити ймовірності для кожного елемента та повторення у вибірці.
# random.sample(population, k): Отримання унікальних випадкових елементів зі списку population довжиною k.
# random.uniform(a, b): Отримання випадкового дійсного числа N такого, що a <= N <= b.

# Модуль math

# Константи:

# math.pi - константа 
# π (приблизно 3.14159...);
# math.e - константа 
# e, основа натуральних логарифмів (приблизно 2.71828...);
# math.tau - константа 
# τ, дорівнює 2π (приблизно 6.28318...);
# math.inf - позначення нескінченності;
# math.nan - позначення 'Not a Number' (не число);


# Функції округлення чисел:

# math.ceil(x) - виконує округлення дійсного числа x до найближчого більшого цілого числа;
# math.floor(x) - виконує округлення дійсного числа x до найближчого меншого цілого числа;
# math.trunc(x) - виконує обрізання дробової частини дійсного числа x, та повертає цілу частину числа;

# Тригонометричні функції
# math.sin(x) - синус x, де x в радіанах;
# math.cos(x) - косинус x;
# math.tan(x) - тангенс x;
# math.asin(x) - арксинус x;
# math.acos(x) - арккосинус x;
# math.atan(x) - арктангенс x;

# Експоненційні та логарифмічні функції
# math.exp(x) - число e в ступені x;
# math.log(x[, base]) - Логарифм x за основою base. Якщо base не вказано, обчислюється натуральний логарифм;

# Ступінь та корінь
# math.pow(x, y) - x у ступені y;
# math.sqrt(x) - квадратний корінь з x;

# Деякі інші функції
# math.fabs(x) - модуль (абсолютне значення) x;
# math.factorial(x) - факторіал числа x;
# math.gcd(x, y) - найбільший спільний дільник для x та y;

# Тригонометрія
import math
angle = math.radians(60)  # Конвертація з градусів у радіани
print(math.sin(angle))  # Синус кута

# Логарифми
print(math.log(10, 2))  # Логарифм 10 за основою 2

# Якщо вам потрібна комплексна математика, то можна скористатися пакетом cmath. Він надає той самий API, але вміє працювати з комплексними числами.

# Функція math.isclose використовується для порівняння двох чисел з певною допустимою похибкою. Це корисно для порівняння дійсних чисел, де пряме порівняння може бути ненадійним.

import re
'''
1234 5432
123456 654321

'''

def validate_pincode(pincode_str: str) -> bool:
    return re.fullmatch(r'[0-9]{4}|[0-9]{6}', pincode_str) is not None
    # return re.match(r'[0-9]{4}|[0-9]{6}', pincode_str) != None

assert validate_pincode("1234") == True
assert validate_pincode("123456") == True
assert validate_pincode("a123") == False
assert validate_pincode("12345") == False


import re
'''
Написати код, який буде аналізувати текст та прибирати в ньому спам слова

Python, Guido van Rossum 

Python is the best programming language!
* is the best programming language!
'''

SPAM_WORDS_LIST = ["Python", "Guido van Rossum"]

def remove_spam_words(message: str) -> str:
    for spam_word in SPAM_WORDS_LIST:
        message = re.sub(rf"\b{spam_word}\b", "*#!", message)
    return message

# assert remove_spam_words("Guido van Rossum") == '*'
# assert remove_spam_words("Python") == '*' # '******'
# assert remove_spam_words("Guido van Rossum Python") == '* *'

print(remove_spam_words("Guido van Rossum began working on Python in the late 1980s as a successor to the ABC programming language and first released it in 1991 as Python 0.9.0."))

# символ \n відповідає за перенос рядка (line break).
# Приклад для повернення каретки \r (carriage return).
print("Hello my little\rsister")
# Керувальний символ \b забій (backspace).
print("Hello\bWorld") #HellWorld
# Щоб екранувати одинарні та подвійні лапки та дозволити використовувати лапки всередині рядкових літералів.
print('It\'s a beautiful day')
print("He said, \"Hello\"")

# Методи рядків
s = "Hi there!"

start = 0
end = 7

print(s.find("er", start, end)) # 5
# Ще один метод пошуку підрядка у рядку дуже схожий на find — це index. Основна відмінність полягає в тому, що якщо index не знайде підрядок, то викличе виняток ValueError.
# Вираз s.find("o") поверне 1, а вираз s.rfind('o') поверне 6 бо шукає справа рядка і матимемо наступне виведення:
# І "правий" аналог index — rindex:
# Метод split() у Python використовується для розбиття рядка на список підрядків на основі вказаного роздільника. Якщо роздільник не вказаний, за замовчуванням використовується пробіл.
# str.split(separator=None, maxsplit=-1)
# string.join(iterable)
list_of_strings = ['Hello', 'world']
result = ' '.join(list_of_strings)
print(result)  # Виведе: 'Hello world'
# Якщо потрібно видалити зайві пробіли на початку і в кінці рядка, є спеціальний метод strip:
clean = '   spacious   '.strip()
print(clean) # spacious
# "лівий", lstrip, видаляє тільки пробіли на початку рядка;
# та "правий", rstrip, видаляє тільки пробіли в кінці рядка.
# str.replace(old, new, count=-1)
text = "Hello world"
new_text = text.replace("world", "Python")
print(new_text) #Hello Python
# Для видалення фіксованої послідовності на початку рядка є метод removeprefix:
print('TestHook'.removeprefix('Test')) # Hook
print('TestHook'.removeprefix('Hook')) # TestHook
# Є парний метод для видалення послідовності в кінці рядка, removesuffix
print('TestHook'.removesuffix('Test'))# TestHook
print('TestHook'.removesuffix('Hook'))#Test

url_search = "<https://www.google.com/search?q=Cat+and+dog&ie=utf-8&oe=utf-8&aq=t>"
_, query = url_search.split('?')
print(query)

# Останній метод який ми розглянемо це isdigit(). Він використовується для перевірки, чи складається рядок повністю з цифр. Цей метод повертає True, якщо всі символи в рядку є цифрами та рядок складається принаймні з одного символу, інакше повертає False.
user_input = input("Введіть число: ")
if user_input.isdigit():
    print("Це дійсно число!")
else:
    print("Це не число!")

    # Метод translate() в Python
intab = "aeiou"
outtab = "12345"
trantab = str.maketrans(intab, outtab)

str = "This is string example"
print(str.translate(trantab))
# Метод translate() також може використовуватися для видалення певних символів із рядка. Для цього передайте в maketrans() третій аргумент - рядок символів, які потрібно видалити.
intab = "aeiou"
trantab = str.maketrans('', '', intab)

str = "This is string example"
print(str.translate(trantab))
# "Ths s strng xmpl"

# ☝ Функція ord() в Python - це вбудована функція, яка використовується для отримання Unicode коду символу. Коли ви працюєте з текстом в Python, кожен символ у рядку має відповідний числовий код - Unicode. Функція ord() приймає символ і повертає його Unicode код, який є цілим числом.

# Наприклад, вивести числа від 1 до 15 в десятковому, шістнадцятковому, вісімковому і двійковому представленні можна наступним чином:

for i in range(8):
    s = f"int: {i:d};  hex: {i:#x};  oct: {i:#o};  bin: {i:#b}"
    print(s)

price = 19.99
quantity = 3
total = f"Total: {price * quantity:.2f}"
print(total)
# У виразі :.2f:
# : вводить специфікацію формату.
# .2 означає, що після десяткової крапки має бути виведено дві цифри.
# f вказує на формат дійсного числа.

width = 5
for num in range(12):
    print(f'{num:^10} {num**2:^10} {num**3:^10}')

# <: Вирівнювання вмісту по лівому краю.
# >: Вирівнювання вмісту по правому краю.
# ^: Вирівнювання вмісту по центру.
# =: Використовується для вирівнювання чисел, при цьому знак (якщо він є) відображається зліва, а число - по правому краю поля.

name = "Alice"
formatted = f"{name:>10}"
print(formatted)  # Виведе: '     Alice' (вирівнювання праворуч)

# Також корисним є форматування відсотків за допомогою f-рядків, що дозволяє зручно відображати числа як відсотки. Для цього використовується специфікатор формату %, який множить число на 100 і додає символ відсотка % до рядка. Це особливо корисно при роботі з даними, де потрібно представляти частки або пропорції у форматі відсотків.
# f"{value:<ширина>.<точність>%}"
# де:
# value - значення, яке потрібно перетворити у відсотки.
# <ширина> - загальна ширина поля; необов'язково.
# <точність> - кількість знаків після десяткової крапки; необов'язково.
completion = 0.756
formatted = f"{completion:.1%}"
print(formatted)  # Виведе: '75.6%'

progress = 0.5
formatted = f"{progress:.0%}"
print(formatted) #50%


# Регулярні вирази (regular expressions, часто скорочують як regex або regexp) - 
# Літерали. Пряме відображення символів (наприклад, a, B, 1).
# Метасимволи. Символи, які мають спеціальне значення в регулярних виразах (наприклад, . (крапка) відповідає будь-якому символу).
# Квантифікатори. Визначають, скільки разів елемент повинен відповідати (наприклад * означає 0 або більше повторень).
# Класи символів. Визначають групи символів (наприклад, [a-z] відповідає будь-якій малій літері).
# Групи та діапазони. Використовуються для групування частин виразу (наприклад, (abc) визначає групу символів).
# Альтернації. Відповідає одному з декількох шаблонів (наприклад, a|b відповідає a або b).
# Якорі. Визначають позиції у тексті (наприклад, ^ для початку рядка, $ для кінця рядка).

# Основні функції модуля re які ми розглянемо далі це:

# re.search(pattern, string) - виконує пошук першого входження шаблону в рядку.
# re.findall(pattern, string) - виконує знаходження всіх входжень шаблону в рядку.
# re.sub(pattern, repl, string) - виконує заміну входжень шаблону на інший рядок.
# re.split(pattern, string) виконує розбивання рядка за шаблоном.

# Прикладом блоку може бути:

# \w — будь-яка цифра або буква [a-zA-Z0-9_] (\W — все, крім букви або цифри [^a-za-z0-9_])
# \d — будь-яка цифра [0-9] (\D — усе, крім цифри [^0-9])
# \s — будь-який пробільний символ [\t\n\r\f\v] (\S — усе, крім пробільних символів [^\t\n\r\f\v])
# \b — межа слова
# [...] — один із символів у дужках ([^ ] — будь-який символ, крім тих, що в дужках)
# ^ і $ — початок і кінець рядка відповідно
# ( ) — групує вираз і повертає знайдений текст
# \t, \n, \r — символ табуляції, нового рядка та повернення каретки

# Результат виконання re.search() це спеціальний об'єкт Match, якщо знаходить відповідність. Якщо відповідність не знайдена, повертає None.
# Match.span() повертає кортеж, що містить початкову та кінцеву позиції збігу.
# Match.string повертає рядок, переданий у функцію,
# Match.group() повертає частину рядка, в якому був збіг
# Ви можете використати метод .group() у цьому об'єкті, щоб отримати відповідну частину рядка.

import re

text = "Вивчення Python може бути веселим."
pattern = "Python"
match = re.search(pattern, text)

if match:
    print("Знайдено:", match.group())
else:
    print("Не знайдено.")


import re

text = "Вивчення Python може бути веселим."
pattern = r"в\w*м"
match = re.search(pattern, text, re.IGNORECASE)

if match:
    print("Знайдено:", match.group())
#   Тут змінна pattern зберігає регулярний вираз r"в\w*м":

# r означає "сирий" рядок (raw string), який каже Python ігнорувати спеціальні символи такі як \n, \t тощо, оскільки це рядок для регулярних виразів.
# в - шукаємо слово яке починається на букву "в".
# \w* - це означає будь-яка кількість букв включно з нулем букв. Бо \w відповідає будь-якому "словесному" символу, а * є квантифікатором, який означає "нуль або більше входжень попереднього елемента".
# м - шукаємо слово яке закінчується на "м".


# В функцію search ми передаємо параметр re.IGNORECASE, який робить пошук нечутливим до регістру. А отже слово може бути як з великих так і малих літер.

import re

text = "Моя електронна адреса: example@example.com"
pattern = r"\w+@\w+\.\w+"
match = re.search(pattern, text)

if match:
    print("Електронна адреса:", match.group())


# У цьому прикладі регулярний вираз \w+@\w+\.\w+ шукає електронну адресу:
# \w+ - спочатку повинні йти одна або більше букв або цифр.
# @ - далі обов'язково повинен бути символ @.
# \w+ - після символу @ повинна йти ще одна серія букв.
# \. - серія букв повинна закінчитись символом крапки. Ми екрануємо його, бо в регулярному виразі, крапка є модифікатором та має спеціальне значення.
# \w+ - далі йде серія букв після крапки.

# Метод findall

# Метод re.findall() використовується для знаходження всіх входжень шаблону, заданого регулярним виразом, у заданому рядку.

import re

text = "Рік 2023 був складнішим, ніж 2022"
pattern = r"\d+"
matches = re.findall(pattern, text)

print(matches)
# ['2023', '2022']

import re

text = "Python - це проста, але потужна мова програмування."
pattern = r"\w+"
matches = re.findall(pattern, text)

print(matches)  # Виведе список всіх слів у рядку
# ['Python', 'це', 'проста', 'але', 'потужна', 'мова', 'програмування']

import re

text = "Контакти: example1@example.com, example2@sample.org"
pattern = r"\w+@\w+\.\w+"
matches = re.findall(pattern, text)

print(matches)  # Виведе всі знайдені електронні адреси
# ['example1@example.com', 'example2@sample.org']

# Метод sub
# Метод re.sub() в модулі re Python використовується для заміни входжень регулярного виразу pattern в рядку string на рядок repl. Це дуже корисно для модифікації тексту.

import re

file_name = "Мій документ Python.txt"
pattern = r"\s"
replacement = "_"
formatted_name = re.sub(pattern, replacement, file_name)

print(formatted_name)  
# Мій_документ_Python.txt

import re

text = "Python - потужна, універсальна; мова!"
pattern = r"[;,\-:!\.]"
replacement = ""
modified_text = re.sub(pattern, replacement, text)

print(modified_text)  

import re

phone = """
        Михайло Куліш: 050-171-1634
        Вікторія Кущ: 063-134-1729
        Оксана Гавриленко: 068-234-5612
        """
pattern = r"(\d{3})-(\d{3})-(\d{4})"
replacement = r"(\1) \2-\3"
formatted_phone = re.sub(pattern, replacement, phone)

print(formatted_phone)

# Метод split

# Функція re.split() в модулі re Python використовується для розбивання рядка за заданим регулярним виразом. Це дозволяє розділяти текст на частини за складнішими критеріями, ніж простий рядковий метод split().

import re

text = "Python - це проста, але потужна мова програмування."
pattern = r"\s+"
words = re.split(pattern, text)

print(words)  # Виведе список слів у рядку
# ['Python', '-', 'це', 'проста,', 'але', 'потужна', 'мова', 'програмування.']

import re

text = "Python - потужна; проста, універсальна: мова!"
pattern = r"[;,\-:!\s]+"
elements = re.split(pattern, text)

print(elements)  # Виведе список частин, розділених пунктуацією
# Тут регулярний вираз [;,\-:!\s]+ збігається з будь-якою послідовністю одного або більше символів з набору ;, ,, -, :, ! або будь-якого пробільного символу. Завдяки квантифікатору +, послідовність роздільників розглядається як один роздільник, що допомагає уникнути створення пустих рядків у результаті виведення.

import re

text = "apple#banana!mango@orange;kiwi"
pattern = r"[#@;!]"
fruits = re.split(pattern, text)

print(fruits)

a = 0
index = 0 if a < 0 else (1 + (a == 0))
print(['negative', 'positive', 'zero'][index])

x = 3 or 5
y = (3) | (5)
print(f"{x=} {y=}")